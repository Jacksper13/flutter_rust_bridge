// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'enumeration_twin_rust_async_sse.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$DistanceTwinRustAsyncSse {
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is DistanceTwinRustAsyncSse);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'DistanceTwinRustAsyncSse()';
  }
}

/// @nodoc
class $DistanceTwinRustAsyncSseCopyWith<$Res> {
  $DistanceTwinRustAsyncSseCopyWith(
      DistanceTwinRustAsyncSse _, $Res Function(DistanceTwinRustAsyncSse) __);
}

/// @nodoc

class DistanceTwinRustAsyncSse_Unknown extends DistanceTwinRustAsyncSse {
  const DistanceTwinRustAsyncSse_Unknown() : super._();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is DistanceTwinRustAsyncSse_Unknown);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'DistanceTwinRustAsyncSse.unknown()';
  }
}

/// @nodoc

class DistanceTwinRustAsyncSse_Map extends DistanceTwinRustAsyncSse {
  const DistanceTwinRustAsyncSse_Map(this.field0) : super._();

  final double field0;

  /// Create a copy of DistanceTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $DistanceTwinRustAsyncSse_MapCopyWith<DistanceTwinRustAsyncSse_Map>
      get copyWith => _$DistanceTwinRustAsyncSse_MapCopyWithImpl<
          DistanceTwinRustAsyncSse_Map>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is DistanceTwinRustAsyncSse_Map &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @override
  String toString() {
    return 'DistanceTwinRustAsyncSse.map(field0: $field0)';
  }
}

/// @nodoc
abstract mixin class $DistanceTwinRustAsyncSse_MapCopyWith<$Res>
    implements $DistanceTwinRustAsyncSseCopyWith<$Res> {
  factory $DistanceTwinRustAsyncSse_MapCopyWith(
          DistanceTwinRustAsyncSse_Map value,
          $Res Function(DistanceTwinRustAsyncSse_Map) _then) =
      _$DistanceTwinRustAsyncSse_MapCopyWithImpl;
  @useResult
  $Res call({double field0});
}

/// @nodoc
class _$DistanceTwinRustAsyncSse_MapCopyWithImpl<$Res>
    implements $DistanceTwinRustAsyncSse_MapCopyWith<$Res> {
  _$DistanceTwinRustAsyncSse_MapCopyWithImpl(this._self, this._then);

  final DistanceTwinRustAsyncSse_Map _self;
  final $Res Function(DistanceTwinRustAsyncSse_Map) _then;

  /// Create a copy of DistanceTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? field0 = null,
  }) {
    return _then(DistanceTwinRustAsyncSse_Map(
      null == field0
          ? _self.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
mixin _$EnumWithItemMixedTwinRustAsyncSse {
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EnumWithItemMixedTwinRustAsyncSse);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'EnumWithItemMixedTwinRustAsyncSse()';
  }
}

/// @nodoc
class $EnumWithItemMixedTwinRustAsyncSseCopyWith<$Res> {
  $EnumWithItemMixedTwinRustAsyncSseCopyWith(
      EnumWithItemMixedTwinRustAsyncSse _,
      $Res Function(EnumWithItemMixedTwinRustAsyncSse) __);
}

/// @nodoc

class EnumWithItemMixedTwinRustAsyncSse_A
    extends EnumWithItemMixedTwinRustAsyncSse {
  const EnumWithItemMixedTwinRustAsyncSse_A() : super._();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EnumWithItemMixedTwinRustAsyncSse_A);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'EnumWithItemMixedTwinRustAsyncSse.a()';
  }
}

/// @nodoc

class EnumWithItemMixedTwinRustAsyncSse_B
    extends EnumWithItemMixedTwinRustAsyncSse {
  const EnumWithItemMixedTwinRustAsyncSse_B(this.field0) : super._();

  final Uint8List field0;

  /// Create a copy of EnumWithItemMixedTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $EnumWithItemMixedTwinRustAsyncSse_BCopyWith<
          EnumWithItemMixedTwinRustAsyncSse_B>
      get copyWith => _$EnumWithItemMixedTwinRustAsyncSse_BCopyWithImpl<
          EnumWithItemMixedTwinRustAsyncSse_B>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EnumWithItemMixedTwinRustAsyncSse_B &&
            const DeepCollectionEquality().equals(other.field0, field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(field0));

  @override
  String toString() {
    return 'EnumWithItemMixedTwinRustAsyncSse.b(field0: $field0)';
  }
}

/// @nodoc
abstract mixin class $EnumWithItemMixedTwinRustAsyncSse_BCopyWith<$Res>
    implements $EnumWithItemMixedTwinRustAsyncSseCopyWith<$Res> {
  factory $EnumWithItemMixedTwinRustAsyncSse_BCopyWith(
          EnumWithItemMixedTwinRustAsyncSse_B value,
          $Res Function(EnumWithItemMixedTwinRustAsyncSse_B) _then) =
      _$EnumWithItemMixedTwinRustAsyncSse_BCopyWithImpl;
  @useResult
  $Res call({Uint8List field0});
}

/// @nodoc
class _$EnumWithItemMixedTwinRustAsyncSse_BCopyWithImpl<$Res>
    implements $EnumWithItemMixedTwinRustAsyncSse_BCopyWith<$Res> {
  _$EnumWithItemMixedTwinRustAsyncSse_BCopyWithImpl(this._self, this._then);

  final EnumWithItemMixedTwinRustAsyncSse_B _self;
  final $Res Function(EnumWithItemMixedTwinRustAsyncSse_B) _then;

  /// Create a copy of EnumWithItemMixedTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? field0 = null,
  }) {
    return _then(EnumWithItemMixedTwinRustAsyncSse_B(
      null == field0
          ? _self.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc

class EnumWithItemMixedTwinRustAsyncSse_C
    extends EnumWithItemMixedTwinRustAsyncSse {
  const EnumWithItemMixedTwinRustAsyncSse_C({required this.cField}) : super._();

  final String cField;

  /// Create a copy of EnumWithItemMixedTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $EnumWithItemMixedTwinRustAsyncSse_CCopyWith<
          EnumWithItemMixedTwinRustAsyncSse_C>
      get copyWith => _$EnumWithItemMixedTwinRustAsyncSse_CCopyWithImpl<
          EnumWithItemMixedTwinRustAsyncSse_C>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EnumWithItemMixedTwinRustAsyncSse_C &&
            (identical(other.cField, cField) || other.cField == cField));
  }

  @override
  int get hashCode => Object.hash(runtimeType, cField);

  @override
  String toString() {
    return 'EnumWithItemMixedTwinRustAsyncSse.c(cField: $cField)';
  }
}

/// @nodoc
abstract mixin class $EnumWithItemMixedTwinRustAsyncSse_CCopyWith<$Res>
    implements $EnumWithItemMixedTwinRustAsyncSseCopyWith<$Res> {
  factory $EnumWithItemMixedTwinRustAsyncSse_CCopyWith(
          EnumWithItemMixedTwinRustAsyncSse_C value,
          $Res Function(EnumWithItemMixedTwinRustAsyncSse_C) _then) =
      _$EnumWithItemMixedTwinRustAsyncSse_CCopyWithImpl;
  @useResult
  $Res call({String cField});
}

/// @nodoc
class _$EnumWithItemMixedTwinRustAsyncSse_CCopyWithImpl<$Res>
    implements $EnumWithItemMixedTwinRustAsyncSse_CCopyWith<$Res> {
  _$EnumWithItemMixedTwinRustAsyncSse_CCopyWithImpl(this._self, this._then);

  final EnumWithItemMixedTwinRustAsyncSse_C _self;
  final $Res Function(EnumWithItemMixedTwinRustAsyncSse_C) _then;

  /// Create a copy of EnumWithItemMixedTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? cField = null,
  }) {
    return _then(EnumWithItemMixedTwinRustAsyncSse_C(
      cField: null == cField
          ? _self.cField
          : cField // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$EnumWithItemStructTwinRustAsyncSse {
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EnumWithItemStructTwinRustAsyncSse);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'EnumWithItemStructTwinRustAsyncSse()';
  }
}

/// @nodoc
class $EnumWithItemStructTwinRustAsyncSseCopyWith<$Res> {
  $EnumWithItemStructTwinRustAsyncSseCopyWith(
      EnumWithItemStructTwinRustAsyncSse _,
      $Res Function(EnumWithItemStructTwinRustAsyncSse) __);
}

/// @nodoc

class EnumWithItemStructTwinRustAsyncSse_A
    extends EnumWithItemStructTwinRustAsyncSse {
  const EnumWithItemStructTwinRustAsyncSse_A({required this.aField})
      : super._();

  final Uint8List aField;

  /// Create a copy of EnumWithItemStructTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $EnumWithItemStructTwinRustAsyncSse_ACopyWith<
          EnumWithItemStructTwinRustAsyncSse_A>
      get copyWith => _$EnumWithItemStructTwinRustAsyncSse_ACopyWithImpl<
          EnumWithItemStructTwinRustAsyncSse_A>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EnumWithItemStructTwinRustAsyncSse_A &&
            const DeepCollectionEquality().equals(other.aField, aField));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(aField));

  @override
  String toString() {
    return 'EnumWithItemStructTwinRustAsyncSse.a(aField: $aField)';
  }
}

/// @nodoc
abstract mixin class $EnumWithItemStructTwinRustAsyncSse_ACopyWith<$Res>
    implements $EnumWithItemStructTwinRustAsyncSseCopyWith<$Res> {
  factory $EnumWithItemStructTwinRustAsyncSse_ACopyWith(
          EnumWithItemStructTwinRustAsyncSse_A value,
          $Res Function(EnumWithItemStructTwinRustAsyncSse_A) _then) =
      _$EnumWithItemStructTwinRustAsyncSse_ACopyWithImpl;
  @useResult
  $Res call({Uint8List aField});
}

/// @nodoc
class _$EnumWithItemStructTwinRustAsyncSse_ACopyWithImpl<$Res>
    implements $EnumWithItemStructTwinRustAsyncSse_ACopyWith<$Res> {
  _$EnumWithItemStructTwinRustAsyncSse_ACopyWithImpl(this._self, this._then);

  final EnumWithItemStructTwinRustAsyncSse_A _self;
  final $Res Function(EnumWithItemStructTwinRustAsyncSse_A) _then;

  /// Create a copy of EnumWithItemStructTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? aField = null,
  }) {
    return _then(EnumWithItemStructTwinRustAsyncSse_A(
      aField: null == aField
          ? _self.aField
          : aField // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc

class EnumWithItemStructTwinRustAsyncSse_B
    extends EnumWithItemStructTwinRustAsyncSse {
  const EnumWithItemStructTwinRustAsyncSse_B({required this.bField})
      : super._();

  final Int32List bField;

  /// Create a copy of EnumWithItemStructTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $EnumWithItemStructTwinRustAsyncSse_BCopyWith<
          EnumWithItemStructTwinRustAsyncSse_B>
      get copyWith => _$EnumWithItemStructTwinRustAsyncSse_BCopyWithImpl<
          EnumWithItemStructTwinRustAsyncSse_B>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EnumWithItemStructTwinRustAsyncSse_B &&
            const DeepCollectionEquality().equals(other.bField, bField));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(bField));

  @override
  String toString() {
    return 'EnumWithItemStructTwinRustAsyncSse.b(bField: $bField)';
  }
}

/// @nodoc
abstract mixin class $EnumWithItemStructTwinRustAsyncSse_BCopyWith<$Res>
    implements $EnumWithItemStructTwinRustAsyncSseCopyWith<$Res> {
  factory $EnumWithItemStructTwinRustAsyncSse_BCopyWith(
          EnumWithItemStructTwinRustAsyncSse_B value,
          $Res Function(EnumWithItemStructTwinRustAsyncSse_B) _then) =
      _$EnumWithItemStructTwinRustAsyncSse_BCopyWithImpl;
  @useResult
  $Res call({Int32List bField});
}

/// @nodoc
class _$EnumWithItemStructTwinRustAsyncSse_BCopyWithImpl<$Res>
    implements $EnumWithItemStructTwinRustAsyncSse_BCopyWith<$Res> {
  _$EnumWithItemStructTwinRustAsyncSse_BCopyWithImpl(this._self, this._then);

  final EnumWithItemStructTwinRustAsyncSse_B _self;
  final $Res Function(EnumWithItemStructTwinRustAsyncSse_B) _then;

  /// Create a copy of EnumWithItemStructTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? bField = null,
  }) {
    return _then(EnumWithItemStructTwinRustAsyncSse_B(
      bField: null == bField
          ? _self.bField
          : bField // ignore: cast_nullable_to_non_nullable
              as Int32List,
    ));
  }
}

/// @nodoc
mixin _$EnumWithItemTupleTwinRustAsyncSse {
  Object get field0;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EnumWithItemTupleTwinRustAsyncSse &&
            const DeepCollectionEquality().equals(other.field0, field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(field0));

  @override
  String toString() {
    return 'EnumWithItemTupleTwinRustAsyncSse(field0: $field0)';
  }
}

/// @nodoc
class $EnumWithItemTupleTwinRustAsyncSseCopyWith<$Res> {
  $EnumWithItemTupleTwinRustAsyncSseCopyWith(
      EnumWithItemTupleTwinRustAsyncSse _,
      $Res Function(EnumWithItemTupleTwinRustAsyncSse) __);
}

/// @nodoc

class EnumWithItemTupleTwinRustAsyncSse_A
    extends EnumWithItemTupleTwinRustAsyncSse {
  const EnumWithItemTupleTwinRustAsyncSse_A(this.field0) : super._();

  @override
  final Uint8List field0;

  /// Create a copy of EnumWithItemTupleTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $EnumWithItemTupleTwinRustAsyncSse_ACopyWith<
          EnumWithItemTupleTwinRustAsyncSse_A>
      get copyWith => _$EnumWithItemTupleTwinRustAsyncSse_ACopyWithImpl<
          EnumWithItemTupleTwinRustAsyncSse_A>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EnumWithItemTupleTwinRustAsyncSse_A &&
            const DeepCollectionEquality().equals(other.field0, field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(field0));

  @override
  String toString() {
    return 'EnumWithItemTupleTwinRustAsyncSse.a(field0: $field0)';
  }
}

/// @nodoc
abstract mixin class $EnumWithItemTupleTwinRustAsyncSse_ACopyWith<$Res>
    implements $EnumWithItemTupleTwinRustAsyncSseCopyWith<$Res> {
  factory $EnumWithItemTupleTwinRustAsyncSse_ACopyWith(
          EnumWithItemTupleTwinRustAsyncSse_A value,
          $Res Function(EnumWithItemTupleTwinRustAsyncSse_A) _then) =
      _$EnumWithItemTupleTwinRustAsyncSse_ACopyWithImpl;
  @useResult
  $Res call({Uint8List field0});
}

/// @nodoc
class _$EnumWithItemTupleTwinRustAsyncSse_ACopyWithImpl<$Res>
    implements $EnumWithItemTupleTwinRustAsyncSse_ACopyWith<$Res> {
  _$EnumWithItemTupleTwinRustAsyncSse_ACopyWithImpl(this._self, this._then);

  final EnumWithItemTupleTwinRustAsyncSse_A _self;
  final $Res Function(EnumWithItemTupleTwinRustAsyncSse_A) _then;

  /// Create a copy of EnumWithItemTupleTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? field0 = null,
  }) {
    return _then(EnumWithItemTupleTwinRustAsyncSse_A(
      null == field0
          ? _self.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc

class EnumWithItemTupleTwinRustAsyncSse_B
    extends EnumWithItemTupleTwinRustAsyncSse {
  const EnumWithItemTupleTwinRustAsyncSse_B(this.field0) : super._();

  @override
  final int field0;

  /// Create a copy of EnumWithItemTupleTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $EnumWithItemTupleTwinRustAsyncSse_BCopyWith<
          EnumWithItemTupleTwinRustAsyncSse_B>
      get copyWith => _$EnumWithItemTupleTwinRustAsyncSse_BCopyWithImpl<
          EnumWithItemTupleTwinRustAsyncSse_B>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EnumWithItemTupleTwinRustAsyncSse_B &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @override
  String toString() {
    return 'EnumWithItemTupleTwinRustAsyncSse.b(field0: $field0)';
  }
}

/// @nodoc
abstract mixin class $EnumWithItemTupleTwinRustAsyncSse_BCopyWith<$Res>
    implements $EnumWithItemTupleTwinRustAsyncSseCopyWith<$Res> {
  factory $EnumWithItemTupleTwinRustAsyncSse_BCopyWith(
          EnumWithItemTupleTwinRustAsyncSse_B value,
          $Res Function(EnumWithItemTupleTwinRustAsyncSse_B) _then) =
      _$EnumWithItemTupleTwinRustAsyncSse_BCopyWithImpl;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class _$EnumWithItemTupleTwinRustAsyncSse_BCopyWithImpl<$Res>
    implements $EnumWithItemTupleTwinRustAsyncSse_BCopyWith<$Res> {
  _$EnumWithItemTupleTwinRustAsyncSse_BCopyWithImpl(this._self, this._then);

  final EnumWithItemTupleTwinRustAsyncSse_B _self;
  final $Res Function(EnumWithItemTupleTwinRustAsyncSse_B) _then;

  /// Create a copy of EnumWithItemTupleTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? field0 = null,
  }) {
    return _then(EnumWithItemTupleTwinRustAsyncSse_B(
      null == field0
          ? _self.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
mixin _$KitchenSinkTwinRustAsyncSse {
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is KitchenSinkTwinRustAsyncSse);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'KitchenSinkTwinRustAsyncSse()';
  }
}

/// @nodoc
class $KitchenSinkTwinRustAsyncSseCopyWith<$Res> {
  $KitchenSinkTwinRustAsyncSseCopyWith(KitchenSinkTwinRustAsyncSse _,
      $Res Function(KitchenSinkTwinRustAsyncSse) __);
}

/// @nodoc

class KitchenSinkTwinRustAsyncSse_Empty extends KitchenSinkTwinRustAsyncSse {
  const KitchenSinkTwinRustAsyncSse_Empty() : super._();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is KitchenSinkTwinRustAsyncSse_Empty);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'KitchenSinkTwinRustAsyncSse.empty()';
  }
}

/// @nodoc

class KitchenSinkTwinRustAsyncSse_Primitives
    extends KitchenSinkTwinRustAsyncSse {
  const KitchenSinkTwinRustAsyncSse_Primitives(
      {this.int32 = -1, required this.float64, required this.boolean})
      : super._();

  /// Dart field comment
  @JsonKey()
  final int int32;
  final double float64;
  final bool boolean;

  /// Create a copy of KitchenSinkTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $KitchenSinkTwinRustAsyncSse_PrimitivesCopyWith<
          KitchenSinkTwinRustAsyncSse_Primitives>
      get copyWith => _$KitchenSinkTwinRustAsyncSse_PrimitivesCopyWithImpl<
          KitchenSinkTwinRustAsyncSse_Primitives>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is KitchenSinkTwinRustAsyncSse_Primitives &&
            (identical(other.int32, int32) || other.int32 == int32) &&
            (identical(other.float64, float64) || other.float64 == float64) &&
            (identical(other.boolean, boolean) || other.boolean == boolean));
  }

  @override
  int get hashCode => Object.hash(runtimeType, int32, float64, boolean);

  @override
  String toString() {
    return 'KitchenSinkTwinRustAsyncSse.primitives(int32: $int32, float64: $float64, boolean: $boolean)';
  }
}

/// @nodoc
abstract mixin class $KitchenSinkTwinRustAsyncSse_PrimitivesCopyWith<$Res>
    implements $KitchenSinkTwinRustAsyncSseCopyWith<$Res> {
  factory $KitchenSinkTwinRustAsyncSse_PrimitivesCopyWith(
          KitchenSinkTwinRustAsyncSse_Primitives value,
          $Res Function(KitchenSinkTwinRustAsyncSse_Primitives) _then) =
      _$KitchenSinkTwinRustAsyncSse_PrimitivesCopyWithImpl;
  @useResult
  $Res call({int int32, double float64, bool boolean});
}

/// @nodoc
class _$KitchenSinkTwinRustAsyncSse_PrimitivesCopyWithImpl<$Res>
    implements $KitchenSinkTwinRustAsyncSse_PrimitivesCopyWith<$Res> {
  _$KitchenSinkTwinRustAsyncSse_PrimitivesCopyWithImpl(this._self, this._then);

  final KitchenSinkTwinRustAsyncSse_Primitives _self;
  final $Res Function(KitchenSinkTwinRustAsyncSse_Primitives) _then;

  /// Create a copy of KitchenSinkTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? int32 = null,
    Object? float64 = null,
    Object? boolean = null,
  }) {
    return _then(KitchenSinkTwinRustAsyncSse_Primitives(
      int32: null == int32
          ? _self.int32
          : int32 // ignore: cast_nullable_to_non_nullable
              as int,
      float64: null == float64
          ? _self.float64
          : float64 // ignore: cast_nullable_to_non_nullable
              as double,
      boolean: null == boolean
          ? _self.boolean
          : boolean // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class KitchenSinkTwinRustAsyncSse_Nested extends KitchenSinkTwinRustAsyncSse {
  const KitchenSinkTwinRustAsyncSse_Nested(this.field0,
      [this.field1 = const KitchenSinkTwinRustAsyncSse.empty()])
      : super._();

  final int field0;
  @JsonKey()
  final KitchenSinkTwinRustAsyncSse field1;

  /// Create a copy of KitchenSinkTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $KitchenSinkTwinRustAsyncSse_NestedCopyWith<
          KitchenSinkTwinRustAsyncSse_Nested>
      get copyWith => _$KitchenSinkTwinRustAsyncSse_NestedCopyWithImpl<
          KitchenSinkTwinRustAsyncSse_Nested>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is KitchenSinkTwinRustAsyncSse_Nested &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1);

  @override
  String toString() {
    return 'KitchenSinkTwinRustAsyncSse.nested(field0: $field0, field1: $field1)';
  }
}

/// @nodoc
abstract mixin class $KitchenSinkTwinRustAsyncSse_NestedCopyWith<$Res>
    implements $KitchenSinkTwinRustAsyncSseCopyWith<$Res> {
  factory $KitchenSinkTwinRustAsyncSse_NestedCopyWith(
          KitchenSinkTwinRustAsyncSse_Nested value,
          $Res Function(KitchenSinkTwinRustAsyncSse_Nested) _then) =
      _$KitchenSinkTwinRustAsyncSse_NestedCopyWithImpl;
  @useResult
  $Res call({int field0, KitchenSinkTwinRustAsyncSse field1});

  $KitchenSinkTwinRustAsyncSseCopyWith<$Res> get field1;
}

/// @nodoc
class _$KitchenSinkTwinRustAsyncSse_NestedCopyWithImpl<$Res>
    implements $KitchenSinkTwinRustAsyncSse_NestedCopyWith<$Res> {
  _$KitchenSinkTwinRustAsyncSse_NestedCopyWithImpl(this._self, this._then);

  final KitchenSinkTwinRustAsyncSse_Nested _self;
  final $Res Function(KitchenSinkTwinRustAsyncSse_Nested) _then;

  /// Create a copy of KitchenSinkTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
  }) {
    return _then(KitchenSinkTwinRustAsyncSse_Nested(
      null == field0
          ? _self.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
      null == field1
          ? _self.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as KitchenSinkTwinRustAsyncSse,
    ));
  }

  /// Create a copy of KitchenSinkTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $KitchenSinkTwinRustAsyncSseCopyWith<$Res> get field1 {
    return $KitchenSinkTwinRustAsyncSseCopyWith<$Res>(_self.field1, (value) {
      return _then(_self.copyWith(field1: value));
    });
  }
}

/// @nodoc

class KitchenSinkTwinRustAsyncSse_Optional extends KitchenSinkTwinRustAsyncSse {
  const KitchenSinkTwinRustAsyncSse_Optional([this.field0 = -1, this.field1])
      : super._();

  /// Comment on anonymous field
  @JsonKey()
  final int? field0;
  final int? field1;

  /// Create a copy of KitchenSinkTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $KitchenSinkTwinRustAsyncSse_OptionalCopyWith<
          KitchenSinkTwinRustAsyncSse_Optional>
      get copyWith => _$KitchenSinkTwinRustAsyncSse_OptionalCopyWithImpl<
          KitchenSinkTwinRustAsyncSse_Optional>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is KitchenSinkTwinRustAsyncSse_Optional &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1);

  @override
  String toString() {
    return 'KitchenSinkTwinRustAsyncSse.optional(field0: $field0, field1: $field1)';
  }
}

/// @nodoc
abstract mixin class $KitchenSinkTwinRustAsyncSse_OptionalCopyWith<$Res>
    implements $KitchenSinkTwinRustAsyncSseCopyWith<$Res> {
  factory $KitchenSinkTwinRustAsyncSse_OptionalCopyWith(
          KitchenSinkTwinRustAsyncSse_Optional value,
          $Res Function(KitchenSinkTwinRustAsyncSse_Optional) _then) =
      _$KitchenSinkTwinRustAsyncSse_OptionalCopyWithImpl;
  @useResult
  $Res call({int? field0, int? field1});
}

/// @nodoc
class _$KitchenSinkTwinRustAsyncSse_OptionalCopyWithImpl<$Res>
    implements $KitchenSinkTwinRustAsyncSse_OptionalCopyWith<$Res> {
  _$KitchenSinkTwinRustAsyncSse_OptionalCopyWithImpl(this._self, this._then);

  final KitchenSinkTwinRustAsyncSse_Optional _self;
  final $Res Function(KitchenSinkTwinRustAsyncSse_Optional) _then;

  /// Create a copy of KitchenSinkTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? field0 = freezed,
    Object? field1 = freezed,
  }) {
    return _then(KitchenSinkTwinRustAsyncSse_Optional(
      freezed == field0
          ? _self.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int?,
      freezed == field1
          ? _self.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class KitchenSinkTwinRustAsyncSse_Buffer extends KitchenSinkTwinRustAsyncSse {
  const KitchenSinkTwinRustAsyncSse_Buffer(this.field0) : super._();

  final Uint8List field0;

  /// Create a copy of KitchenSinkTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $KitchenSinkTwinRustAsyncSse_BufferCopyWith<
          KitchenSinkTwinRustAsyncSse_Buffer>
      get copyWith => _$KitchenSinkTwinRustAsyncSse_BufferCopyWithImpl<
          KitchenSinkTwinRustAsyncSse_Buffer>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is KitchenSinkTwinRustAsyncSse_Buffer &&
            const DeepCollectionEquality().equals(other.field0, field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(field0));

  @override
  String toString() {
    return 'KitchenSinkTwinRustAsyncSse.buffer(field0: $field0)';
  }
}

/// @nodoc
abstract mixin class $KitchenSinkTwinRustAsyncSse_BufferCopyWith<$Res>
    implements $KitchenSinkTwinRustAsyncSseCopyWith<$Res> {
  factory $KitchenSinkTwinRustAsyncSse_BufferCopyWith(
          KitchenSinkTwinRustAsyncSse_Buffer value,
          $Res Function(KitchenSinkTwinRustAsyncSse_Buffer) _then) =
      _$KitchenSinkTwinRustAsyncSse_BufferCopyWithImpl;
  @useResult
  $Res call({Uint8List field0});
}

/// @nodoc
class _$KitchenSinkTwinRustAsyncSse_BufferCopyWithImpl<$Res>
    implements $KitchenSinkTwinRustAsyncSse_BufferCopyWith<$Res> {
  _$KitchenSinkTwinRustAsyncSse_BufferCopyWithImpl(this._self, this._then);

  final KitchenSinkTwinRustAsyncSse_Buffer _self;
  final $Res Function(KitchenSinkTwinRustAsyncSse_Buffer) _then;

  /// Create a copy of KitchenSinkTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? field0 = null,
  }) {
    return _then(KitchenSinkTwinRustAsyncSse_Buffer(
      null == field0
          ? _self.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc

class KitchenSinkTwinRustAsyncSse_Enums extends KitchenSinkTwinRustAsyncSse {
  const KitchenSinkTwinRustAsyncSse_Enums(
      [this.field0 = WeekdaysTwinRustAsyncSse.sunday])
      : super._();

  @JsonKey()
  final WeekdaysTwinRustAsyncSse field0;

  /// Create a copy of KitchenSinkTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $KitchenSinkTwinRustAsyncSse_EnumsCopyWith<KitchenSinkTwinRustAsyncSse_Enums>
      get copyWith => _$KitchenSinkTwinRustAsyncSse_EnumsCopyWithImpl<
          KitchenSinkTwinRustAsyncSse_Enums>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is KitchenSinkTwinRustAsyncSse_Enums &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @override
  String toString() {
    return 'KitchenSinkTwinRustAsyncSse.enums(field0: $field0)';
  }
}

/// @nodoc
abstract mixin class $KitchenSinkTwinRustAsyncSse_EnumsCopyWith<$Res>
    implements $KitchenSinkTwinRustAsyncSseCopyWith<$Res> {
  factory $KitchenSinkTwinRustAsyncSse_EnumsCopyWith(
          KitchenSinkTwinRustAsyncSse_Enums value,
          $Res Function(KitchenSinkTwinRustAsyncSse_Enums) _then) =
      _$KitchenSinkTwinRustAsyncSse_EnumsCopyWithImpl;
  @useResult
  $Res call({WeekdaysTwinRustAsyncSse field0});
}

/// @nodoc
class _$KitchenSinkTwinRustAsyncSse_EnumsCopyWithImpl<$Res>
    implements $KitchenSinkTwinRustAsyncSse_EnumsCopyWith<$Res> {
  _$KitchenSinkTwinRustAsyncSse_EnumsCopyWithImpl(this._self, this._then);

  final KitchenSinkTwinRustAsyncSse_Enums _self;
  final $Res Function(KitchenSinkTwinRustAsyncSse_Enums) _then;

  /// Create a copy of KitchenSinkTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? field0 = null,
  }) {
    return _then(KitchenSinkTwinRustAsyncSse_Enums(
      null == field0
          ? _self.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as WeekdaysTwinRustAsyncSse,
    ));
  }
}

/// @nodoc
mixin _$MeasureTwinRustAsyncSse {
  Object get field0;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MeasureTwinRustAsyncSse &&
            const DeepCollectionEquality().equals(other.field0, field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(field0));

  @override
  String toString() {
    return 'MeasureTwinRustAsyncSse(field0: $field0)';
  }
}

/// @nodoc
class $MeasureTwinRustAsyncSseCopyWith<$Res> {
  $MeasureTwinRustAsyncSseCopyWith(
      MeasureTwinRustAsyncSse _, $Res Function(MeasureTwinRustAsyncSse) __);
}

/// @nodoc

class MeasureTwinRustAsyncSse_Speed extends MeasureTwinRustAsyncSse {
  const MeasureTwinRustAsyncSse_Speed(this.field0) : super._();

  @override
  final SpeedTwinRustAsyncSse field0;

  /// Create a copy of MeasureTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MeasureTwinRustAsyncSse_SpeedCopyWith<MeasureTwinRustAsyncSse_Speed>
      get copyWith => _$MeasureTwinRustAsyncSse_SpeedCopyWithImpl<
          MeasureTwinRustAsyncSse_Speed>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MeasureTwinRustAsyncSse_Speed &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @override
  String toString() {
    return 'MeasureTwinRustAsyncSse.speed(field0: $field0)';
  }
}

/// @nodoc
abstract mixin class $MeasureTwinRustAsyncSse_SpeedCopyWith<$Res>
    implements $MeasureTwinRustAsyncSseCopyWith<$Res> {
  factory $MeasureTwinRustAsyncSse_SpeedCopyWith(
          MeasureTwinRustAsyncSse_Speed value,
          $Res Function(MeasureTwinRustAsyncSse_Speed) _then) =
      _$MeasureTwinRustAsyncSse_SpeedCopyWithImpl;
  @useResult
  $Res call({SpeedTwinRustAsyncSse field0});

  $SpeedTwinRustAsyncSseCopyWith<$Res> get field0;
}

/// @nodoc
class _$MeasureTwinRustAsyncSse_SpeedCopyWithImpl<$Res>
    implements $MeasureTwinRustAsyncSse_SpeedCopyWith<$Res> {
  _$MeasureTwinRustAsyncSse_SpeedCopyWithImpl(this._self, this._then);

  final MeasureTwinRustAsyncSse_Speed _self;
  final $Res Function(MeasureTwinRustAsyncSse_Speed) _then;

  /// Create a copy of MeasureTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? field0 = null,
  }) {
    return _then(MeasureTwinRustAsyncSse_Speed(
      null == field0
          ? _self.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as SpeedTwinRustAsyncSse,
    ));
  }

  /// Create a copy of MeasureTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $SpeedTwinRustAsyncSseCopyWith<$Res> get field0 {
    return $SpeedTwinRustAsyncSseCopyWith<$Res>(_self.field0, (value) {
      return _then(_self.copyWith(field0: value));
    });
  }
}

/// @nodoc

class MeasureTwinRustAsyncSse_Distance extends MeasureTwinRustAsyncSse {
  const MeasureTwinRustAsyncSse_Distance(this.field0) : super._();

  @override
  final DistanceTwinRustAsyncSse field0;

  /// Create a copy of MeasureTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MeasureTwinRustAsyncSse_DistanceCopyWith<MeasureTwinRustAsyncSse_Distance>
      get copyWith => _$MeasureTwinRustAsyncSse_DistanceCopyWithImpl<
          MeasureTwinRustAsyncSse_Distance>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MeasureTwinRustAsyncSse_Distance &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @override
  String toString() {
    return 'MeasureTwinRustAsyncSse.distance(field0: $field0)';
  }
}

/// @nodoc
abstract mixin class $MeasureTwinRustAsyncSse_DistanceCopyWith<$Res>
    implements $MeasureTwinRustAsyncSseCopyWith<$Res> {
  factory $MeasureTwinRustAsyncSse_DistanceCopyWith(
          MeasureTwinRustAsyncSse_Distance value,
          $Res Function(MeasureTwinRustAsyncSse_Distance) _then) =
      _$MeasureTwinRustAsyncSse_DistanceCopyWithImpl;
  @useResult
  $Res call({DistanceTwinRustAsyncSse field0});

  $DistanceTwinRustAsyncSseCopyWith<$Res> get field0;
}

/// @nodoc
class _$MeasureTwinRustAsyncSse_DistanceCopyWithImpl<$Res>
    implements $MeasureTwinRustAsyncSse_DistanceCopyWith<$Res> {
  _$MeasureTwinRustAsyncSse_DistanceCopyWithImpl(this._self, this._then);

  final MeasureTwinRustAsyncSse_Distance _self;
  final $Res Function(MeasureTwinRustAsyncSse_Distance) _then;

  /// Create a copy of MeasureTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? field0 = null,
  }) {
    return _then(MeasureTwinRustAsyncSse_Distance(
      null == field0
          ? _self.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as DistanceTwinRustAsyncSse,
    ));
  }

  /// Create a copy of MeasureTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $DistanceTwinRustAsyncSseCopyWith<$Res> get field0 {
    return $DistanceTwinRustAsyncSseCopyWith<$Res>(_self.field0, (value) {
      return _then(_self.copyWith(field0: value));
    });
  }
}

/// @nodoc
mixin _$SpeedTwinRustAsyncSse {
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is SpeedTwinRustAsyncSse);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'SpeedTwinRustAsyncSse()';
  }
}

/// @nodoc
class $SpeedTwinRustAsyncSseCopyWith<$Res> {
  $SpeedTwinRustAsyncSseCopyWith(
      SpeedTwinRustAsyncSse _, $Res Function(SpeedTwinRustAsyncSse) __);
}

/// @nodoc

class SpeedTwinRustAsyncSse_Unknown extends SpeedTwinRustAsyncSse {
  const SpeedTwinRustAsyncSse_Unknown() : super._();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SpeedTwinRustAsyncSse_Unknown);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'SpeedTwinRustAsyncSse.unknown()';
  }
}

/// @nodoc

class SpeedTwinRustAsyncSse_GPS extends SpeedTwinRustAsyncSse {
  const SpeedTwinRustAsyncSse_GPS(this.field0) : super._();

  final double field0;

  /// Create a copy of SpeedTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $SpeedTwinRustAsyncSse_GPSCopyWith<SpeedTwinRustAsyncSse_GPS> get copyWith =>
      _$SpeedTwinRustAsyncSse_GPSCopyWithImpl<SpeedTwinRustAsyncSse_GPS>(
          this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SpeedTwinRustAsyncSse_GPS &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @override
  String toString() {
    return 'SpeedTwinRustAsyncSse.gps(field0: $field0)';
  }
}

/// @nodoc
abstract mixin class $SpeedTwinRustAsyncSse_GPSCopyWith<$Res>
    implements $SpeedTwinRustAsyncSseCopyWith<$Res> {
  factory $SpeedTwinRustAsyncSse_GPSCopyWith(SpeedTwinRustAsyncSse_GPS value,
          $Res Function(SpeedTwinRustAsyncSse_GPS) _then) =
      _$SpeedTwinRustAsyncSse_GPSCopyWithImpl;
  @useResult
  $Res call({double field0});
}

/// @nodoc
class _$SpeedTwinRustAsyncSse_GPSCopyWithImpl<$Res>
    implements $SpeedTwinRustAsyncSse_GPSCopyWith<$Res> {
  _$SpeedTwinRustAsyncSse_GPSCopyWithImpl(this._self, this._then);

  final SpeedTwinRustAsyncSse_GPS _self;
  final $Res Function(SpeedTwinRustAsyncSse_GPS) _then;

  /// Create a copy of SpeedTwinRustAsyncSse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? field0 = null,
  }) {
    return _then(SpeedTwinRustAsyncSse_GPS(
      null == field0
          ? _self.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

// dart format on
