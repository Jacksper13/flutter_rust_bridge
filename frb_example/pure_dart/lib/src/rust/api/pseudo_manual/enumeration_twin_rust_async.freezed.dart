// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'enumeration_twin_rust_async.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$DistanceTwinRustAsync {
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is DistanceTwinRustAsync);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'DistanceTwinRustAsync()';
  }
}

/// @nodoc
class $DistanceTwinRustAsyncCopyWith<$Res> {
  $DistanceTwinRustAsyncCopyWith(
      DistanceTwinRustAsync _, $Res Function(DistanceTwinRustAsync) __);
}

/// @nodoc

class DistanceTwinRustAsync_Unknown extends DistanceTwinRustAsync {
  const DistanceTwinRustAsync_Unknown() : super._();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is DistanceTwinRustAsync_Unknown);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'DistanceTwinRustAsync.unknown()';
  }
}

/// @nodoc

class DistanceTwinRustAsync_Map extends DistanceTwinRustAsync {
  const DistanceTwinRustAsync_Map(this.field0) : super._();

  final double field0;

  /// Create a copy of DistanceTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $DistanceTwinRustAsync_MapCopyWith<DistanceTwinRustAsync_Map> get copyWith =>
      _$DistanceTwinRustAsync_MapCopyWithImpl<DistanceTwinRustAsync_Map>(
          this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is DistanceTwinRustAsync_Map &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @override
  String toString() {
    return 'DistanceTwinRustAsync.map(field0: $field0)';
  }
}

/// @nodoc
abstract mixin class $DistanceTwinRustAsync_MapCopyWith<$Res>
    implements $DistanceTwinRustAsyncCopyWith<$Res> {
  factory $DistanceTwinRustAsync_MapCopyWith(DistanceTwinRustAsync_Map value,
          $Res Function(DistanceTwinRustAsync_Map) _then) =
      _$DistanceTwinRustAsync_MapCopyWithImpl;
  @useResult
  $Res call({double field0});
}

/// @nodoc
class _$DistanceTwinRustAsync_MapCopyWithImpl<$Res>
    implements $DistanceTwinRustAsync_MapCopyWith<$Res> {
  _$DistanceTwinRustAsync_MapCopyWithImpl(this._self, this._then);

  final DistanceTwinRustAsync_Map _self;
  final $Res Function(DistanceTwinRustAsync_Map) _then;

  /// Create a copy of DistanceTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? field0 = null,
  }) {
    return _then(DistanceTwinRustAsync_Map(
      null == field0
          ? _self.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
mixin _$EnumWithItemMixedTwinRustAsync {
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EnumWithItemMixedTwinRustAsync);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'EnumWithItemMixedTwinRustAsync()';
  }
}

/// @nodoc
class $EnumWithItemMixedTwinRustAsyncCopyWith<$Res> {
  $EnumWithItemMixedTwinRustAsyncCopyWith(EnumWithItemMixedTwinRustAsync _,
      $Res Function(EnumWithItemMixedTwinRustAsync) __);
}

/// @nodoc

class EnumWithItemMixedTwinRustAsync_A extends EnumWithItemMixedTwinRustAsync {
  const EnumWithItemMixedTwinRustAsync_A() : super._();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EnumWithItemMixedTwinRustAsync_A);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'EnumWithItemMixedTwinRustAsync.a()';
  }
}

/// @nodoc

class EnumWithItemMixedTwinRustAsync_B extends EnumWithItemMixedTwinRustAsync {
  const EnumWithItemMixedTwinRustAsync_B(this.field0) : super._();

  final Uint8List field0;

  /// Create a copy of EnumWithItemMixedTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $EnumWithItemMixedTwinRustAsync_BCopyWith<EnumWithItemMixedTwinRustAsync_B>
      get copyWith => _$EnumWithItemMixedTwinRustAsync_BCopyWithImpl<
          EnumWithItemMixedTwinRustAsync_B>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EnumWithItemMixedTwinRustAsync_B &&
            const DeepCollectionEquality().equals(other.field0, field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(field0));

  @override
  String toString() {
    return 'EnumWithItemMixedTwinRustAsync.b(field0: $field0)';
  }
}

/// @nodoc
abstract mixin class $EnumWithItemMixedTwinRustAsync_BCopyWith<$Res>
    implements $EnumWithItemMixedTwinRustAsyncCopyWith<$Res> {
  factory $EnumWithItemMixedTwinRustAsync_BCopyWith(
          EnumWithItemMixedTwinRustAsync_B value,
          $Res Function(EnumWithItemMixedTwinRustAsync_B) _then) =
      _$EnumWithItemMixedTwinRustAsync_BCopyWithImpl;
  @useResult
  $Res call({Uint8List field0});
}

/// @nodoc
class _$EnumWithItemMixedTwinRustAsync_BCopyWithImpl<$Res>
    implements $EnumWithItemMixedTwinRustAsync_BCopyWith<$Res> {
  _$EnumWithItemMixedTwinRustAsync_BCopyWithImpl(this._self, this._then);

  final EnumWithItemMixedTwinRustAsync_B _self;
  final $Res Function(EnumWithItemMixedTwinRustAsync_B) _then;

  /// Create a copy of EnumWithItemMixedTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? field0 = null,
  }) {
    return _then(EnumWithItemMixedTwinRustAsync_B(
      null == field0
          ? _self.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc

class EnumWithItemMixedTwinRustAsync_C extends EnumWithItemMixedTwinRustAsync {
  const EnumWithItemMixedTwinRustAsync_C({required this.cField}) : super._();

  final String cField;

  /// Create a copy of EnumWithItemMixedTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $EnumWithItemMixedTwinRustAsync_CCopyWith<EnumWithItemMixedTwinRustAsync_C>
      get copyWith => _$EnumWithItemMixedTwinRustAsync_CCopyWithImpl<
          EnumWithItemMixedTwinRustAsync_C>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EnumWithItemMixedTwinRustAsync_C &&
            (identical(other.cField, cField) || other.cField == cField));
  }

  @override
  int get hashCode => Object.hash(runtimeType, cField);

  @override
  String toString() {
    return 'EnumWithItemMixedTwinRustAsync.c(cField: $cField)';
  }
}

/// @nodoc
abstract mixin class $EnumWithItemMixedTwinRustAsync_CCopyWith<$Res>
    implements $EnumWithItemMixedTwinRustAsyncCopyWith<$Res> {
  factory $EnumWithItemMixedTwinRustAsync_CCopyWith(
          EnumWithItemMixedTwinRustAsync_C value,
          $Res Function(EnumWithItemMixedTwinRustAsync_C) _then) =
      _$EnumWithItemMixedTwinRustAsync_CCopyWithImpl;
  @useResult
  $Res call({String cField});
}

/// @nodoc
class _$EnumWithItemMixedTwinRustAsync_CCopyWithImpl<$Res>
    implements $EnumWithItemMixedTwinRustAsync_CCopyWith<$Res> {
  _$EnumWithItemMixedTwinRustAsync_CCopyWithImpl(this._self, this._then);

  final EnumWithItemMixedTwinRustAsync_C _self;
  final $Res Function(EnumWithItemMixedTwinRustAsync_C) _then;

  /// Create a copy of EnumWithItemMixedTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? cField = null,
  }) {
    return _then(EnumWithItemMixedTwinRustAsync_C(
      cField: null == cField
          ? _self.cField
          : cField // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$EnumWithItemStructTwinRustAsync {
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EnumWithItemStructTwinRustAsync);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'EnumWithItemStructTwinRustAsync()';
  }
}

/// @nodoc
class $EnumWithItemStructTwinRustAsyncCopyWith<$Res> {
  $EnumWithItemStructTwinRustAsyncCopyWith(EnumWithItemStructTwinRustAsync _,
      $Res Function(EnumWithItemStructTwinRustAsync) __);
}

/// @nodoc

class EnumWithItemStructTwinRustAsync_A
    extends EnumWithItemStructTwinRustAsync {
  const EnumWithItemStructTwinRustAsync_A({required this.aField}) : super._();

  final Uint8List aField;

  /// Create a copy of EnumWithItemStructTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $EnumWithItemStructTwinRustAsync_ACopyWith<EnumWithItemStructTwinRustAsync_A>
      get copyWith => _$EnumWithItemStructTwinRustAsync_ACopyWithImpl<
          EnumWithItemStructTwinRustAsync_A>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EnumWithItemStructTwinRustAsync_A &&
            const DeepCollectionEquality().equals(other.aField, aField));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(aField));

  @override
  String toString() {
    return 'EnumWithItemStructTwinRustAsync.a(aField: $aField)';
  }
}

/// @nodoc
abstract mixin class $EnumWithItemStructTwinRustAsync_ACopyWith<$Res>
    implements $EnumWithItemStructTwinRustAsyncCopyWith<$Res> {
  factory $EnumWithItemStructTwinRustAsync_ACopyWith(
          EnumWithItemStructTwinRustAsync_A value,
          $Res Function(EnumWithItemStructTwinRustAsync_A) _then) =
      _$EnumWithItemStructTwinRustAsync_ACopyWithImpl;
  @useResult
  $Res call({Uint8List aField});
}

/// @nodoc
class _$EnumWithItemStructTwinRustAsync_ACopyWithImpl<$Res>
    implements $EnumWithItemStructTwinRustAsync_ACopyWith<$Res> {
  _$EnumWithItemStructTwinRustAsync_ACopyWithImpl(this._self, this._then);

  final EnumWithItemStructTwinRustAsync_A _self;
  final $Res Function(EnumWithItemStructTwinRustAsync_A) _then;

  /// Create a copy of EnumWithItemStructTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? aField = null,
  }) {
    return _then(EnumWithItemStructTwinRustAsync_A(
      aField: null == aField
          ? _self.aField
          : aField // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc

class EnumWithItemStructTwinRustAsync_B
    extends EnumWithItemStructTwinRustAsync {
  const EnumWithItemStructTwinRustAsync_B({required this.bField}) : super._();

  final Int32List bField;

  /// Create a copy of EnumWithItemStructTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $EnumWithItemStructTwinRustAsync_BCopyWith<EnumWithItemStructTwinRustAsync_B>
      get copyWith => _$EnumWithItemStructTwinRustAsync_BCopyWithImpl<
          EnumWithItemStructTwinRustAsync_B>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EnumWithItemStructTwinRustAsync_B &&
            const DeepCollectionEquality().equals(other.bField, bField));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(bField));

  @override
  String toString() {
    return 'EnumWithItemStructTwinRustAsync.b(bField: $bField)';
  }
}

/// @nodoc
abstract mixin class $EnumWithItemStructTwinRustAsync_BCopyWith<$Res>
    implements $EnumWithItemStructTwinRustAsyncCopyWith<$Res> {
  factory $EnumWithItemStructTwinRustAsync_BCopyWith(
          EnumWithItemStructTwinRustAsync_B value,
          $Res Function(EnumWithItemStructTwinRustAsync_B) _then) =
      _$EnumWithItemStructTwinRustAsync_BCopyWithImpl;
  @useResult
  $Res call({Int32List bField});
}

/// @nodoc
class _$EnumWithItemStructTwinRustAsync_BCopyWithImpl<$Res>
    implements $EnumWithItemStructTwinRustAsync_BCopyWith<$Res> {
  _$EnumWithItemStructTwinRustAsync_BCopyWithImpl(this._self, this._then);

  final EnumWithItemStructTwinRustAsync_B _self;
  final $Res Function(EnumWithItemStructTwinRustAsync_B) _then;

  /// Create a copy of EnumWithItemStructTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? bField = null,
  }) {
    return _then(EnumWithItemStructTwinRustAsync_B(
      bField: null == bField
          ? _self.bField
          : bField // ignore: cast_nullable_to_non_nullable
              as Int32List,
    ));
  }
}

/// @nodoc
mixin _$EnumWithItemTupleTwinRustAsync {
  Object get field0;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EnumWithItemTupleTwinRustAsync &&
            const DeepCollectionEquality().equals(other.field0, field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(field0));

  @override
  String toString() {
    return 'EnumWithItemTupleTwinRustAsync(field0: $field0)';
  }
}

/// @nodoc
class $EnumWithItemTupleTwinRustAsyncCopyWith<$Res> {
  $EnumWithItemTupleTwinRustAsyncCopyWith(EnumWithItemTupleTwinRustAsync _,
      $Res Function(EnumWithItemTupleTwinRustAsync) __);
}

/// @nodoc

class EnumWithItemTupleTwinRustAsync_A extends EnumWithItemTupleTwinRustAsync {
  const EnumWithItemTupleTwinRustAsync_A(this.field0) : super._();

  @override
  final Uint8List field0;

  /// Create a copy of EnumWithItemTupleTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $EnumWithItemTupleTwinRustAsync_ACopyWith<EnumWithItemTupleTwinRustAsync_A>
      get copyWith => _$EnumWithItemTupleTwinRustAsync_ACopyWithImpl<
          EnumWithItemTupleTwinRustAsync_A>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EnumWithItemTupleTwinRustAsync_A &&
            const DeepCollectionEquality().equals(other.field0, field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(field0));

  @override
  String toString() {
    return 'EnumWithItemTupleTwinRustAsync.a(field0: $field0)';
  }
}

/// @nodoc
abstract mixin class $EnumWithItemTupleTwinRustAsync_ACopyWith<$Res>
    implements $EnumWithItemTupleTwinRustAsyncCopyWith<$Res> {
  factory $EnumWithItemTupleTwinRustAsync_ACopyWith(
          EnumWithItemTupleTwinRustAsync_A value,
          $Res Function(EnumWithItemTupleTwinRustAsync_A) _then) =
      _$EnumWithItemTupleTwinRustAsync_ACopyWithImpl;
  @useResult
  $Res call({Uint8List field0});
}

/// @nodoc
class _$EnumWithItemTupleTwinRustAsync_ACopyWithImpl<$Res>
    implements $EnumWithItemTupleTwinRustAsync_ACopyWith<$Res> {
  _$EnumWithItemTupleTwinRustAsync_ACopyWithImpl(this._self, this._then);

  final EnumWithItemTupleTwinRustAsync_A _self;
  final $Res Function(EnumWithItemTupleTwinRustAsync_A) _then;

  /// Create a copy of EnumWithItemTupleTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? field0 = null,
  }) {
    return _then(EnumWithItemTupleTwinRustAsync_A(
      null == field0
          ? _self.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc

class EnumWithItemTupleTwinRustAsync_B extends EnumWithItemTupleTwinRustAsync {
  const EnumWithItemTupleTwinRustAsync_B(this.field0) : super._();

  @override
  final int field0;

  /// Create a copy of EnumWithItemTupleTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $EnumWithItemTupleTwinRustAsync_BCopyWith<EnumWithItemTupleTwinRustAsync_B>
      get copyWith => _$EnumWithItemTupleTwinRustAsync_BCopyWithImpl<
          EnumWithItemTupleTwinRustAsync_B>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EnumWithItemTupleTwinRustAsync_B &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @override
  String toString() {
    return 'EnumWithItemTupleTwinRustAsync.b(field0: $field0)';
  }
}

/// @nodoc
abstract mixin class $EnumWithItemTupleTwinRustAsync_BCopyWith<$Res>
    implements $EnumWithItemTupleTwinRustAsyncCopyWith<$Res> {
  factory $EnumWithItemTupleTwinRustAsync_BCopyWith(
          EnumWithItemTupleTwinRustAsync_B value,
          $Res Function(EnumWithItemTupleTwinRustAsync_B) _then) =
      _$EnumWithItemTupleTwinRustAsync_BCopyWithImpl;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class _$EnumWithItemTupleTwinRustAsync_BCopyWithImpl<$Res>
    implements $EnumWithItemTupleTwinRustAsync_BCopyWith<$Res> {
  _$EnumWithItemTupleTwinRustAsync_BCopyWithImpl(this._self, this._then);

  final EnumWithItemTupleTwinRustAsync_B _self;
  final $Res Function(EnumWithItemTupleTwinRustAsync_B) _then;

  /// Create a copy of EnumWithItemTupleTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? field0 = null,
  }) {
    return _then(EnumWithItemTupleTwinRustAsync_B(
      null == field0
          ? _self.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
mixin _$KitchenSinkTwinRustAsync {
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is KitchenSinkTwinRustAsync);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'KitchenSinkTwinRustAsync()';
  }
}

/// @nodoc
class $KitchenSinkTwinRustAsyncCopyWith<$Res> {
  $KitchenSinkTwinRustAsyncCopyWith(
      KitchenSinkTwinRustAsync _, $Res Function(KitchenSinkTwinRustAsync) __);
}

/// @nodoc

class KitchenSinkTwinRustAsync_Empty extends KitchenSinkTwinRustAsync {
  const KitchenSinkTwinRustAsync_Empty() : super._();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is KitchenSinkTwinRustAsync_Empty);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'KitchenSinkTwinRustAsync.empty()';
  }
}

/// @nodoc

class KitchenSinkTwinRustAsync_Primitives extends KitchenSinkTwinRustAsync {
  const KitchenSinkTwinRustAsync_Primitives(
      {this.int32 = -1, required this.float64, required this.boolean})
      : super._();

  /// Dart field comment
  @JsonKey()
  final int int32;
  final double float64;
  final bool boolean;

  /// Create a copy of KitchenSinkTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $KitchenSinkTwinRustAsync_PrimitivesCopyWith<
          KitchenSinkTwinRustAsync_Primitives>
      get copyWith => _$KitchenSinkTwinRustAsync_PrimitivesCopyWithImpl<
          KitchenSinkTwinRustAsync_Primitives>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is KitchenSinkTwinRustAsync_Primitives &&
            (identical(other.int32, int32) || other.int32 == int32) &&
            (identical(other.float64, float64) || other.float64 == float64) &&
            (identical(other.boolean, boolean) || other.boolean == boolean));
  }

  @override
  int get hashCode => Object.hash(runtimeType, int32, float64, boolean);

  @override
  String toString() {
    return 'KitchenSinkTwinRustAsync.primitives(int32: $int32, float64: $float64, boolean: $boolean)';
  }
}

/// @nodoc
abstract mixin class $KitchenSinkTwinRustAsync_PrimitivesCopyWith<$Res>
    implements $KitchenSinkTwinRustAsyncCopyWith<$Res> {
  factory $KitchenSinkTwinRustAsync_PrimitivesCopyWith(
          KitchenSinkTwinRustAsync_Primitives value,
          $Res Function(KitchenSinkTwinRustAsync_Primitives) _then) =
      _$KitchenSinkTwinRustAsync_PrimitivesCopyWithImpl;
  @useResult
  $Res call({int int32, double float64, bool boolean});
}

/// @nodoc
class _$KitchenSinkTwinRustAsync_PrimitivesCopyWithImpl<$Res>
    implements $KitchenSinkTwinRustAsync_PrimitivesCopyWith<$Res> {
  _$KitchenSinkTwinRustAsync_PrimitivesCopyWithImpl(this._self, this._then);

  final KitchenSinkTwinRustAsync_Primitives _self;
  final $Res Function(KitchenSinkTwinRustAsync_Primitives) _then;

  /// Create a copy of KitchenSinkTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? int32 = null,
    Object? float64 = null,
    Object? boolean = null,
  }) {
    return _then(KitchenSinkTwinRustAsync_Primitives(
      int32: null == int32
          ? _self.int32
          : int32 // ignore: cast_nullable_to_non_nullable
              as int,
      float64: null == float64
          ? _self.float64
          : float64 // ignore: cast_nullable_to_non_nullable
              as double,
      boolean: null == boolean
          ? _self.boolean
          : boolean // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class KitchenSinkTwinRustAsync_Nested extends KitchenSinkTwinRustAsync {
  const KitchenSinkTwinRustAsync_Nested(this.field0,
      [this.field1 = const KitchenSinkTwinRustAsync.empty()])
      : super._();

  final int field0;
  @JsonKey()
  final KitchenSinkTwinRustAsync field1;

  /// Create a copy of KitchenSinkTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $KitchenSinkTwinRustAsync_NestedCopyWith<KitchenSinkTwinRustAsync_Nested>
      get copyWith => _$KitchenSinkTwinRustAsync_NestedCopyWithImpl<
          KitchenSinkTwinRustAsync_Nested>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is KitchenSinkTwinRustAsync_Nested &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1);

  @override
  String toString() {
    return 'KitchenSinkTwinRustAsync.nested(field0: $field0, field1: $field1)';
  }
}

/// @nodoc
abstract mixin class $KitchenSinkTwinRustAsync_NestedCopyWith<$Res>
    implements $KitchenSinkTwinRustAsyncCopyWith<$Res> {
  factory $KitchenSinkTwinRustAsync_NestedCopyWith(
          KitchenSinkTwinRustAsync_Nested value,
          $Res Function(KitchenSinkTwinRustAsync_Nested) _then) =
      _$KitchenSinkTwinRustAsync_NestedCopyWithImpl;
  @useResult
  $Res call({int field0, KitchenSinkTwinRustAsync field1});

  $KitchenSinkTwinRustAsyncCopyWith<$Res> get field1;
}

/// @nodoc
class _$KitchenSinkTwinRustAsync_NestedCopyWithImpl<$Res>
    implements $KitchenSinkTwinRustAsync_NestedCopyWith<$Res> {
  _$KitchenSinkTwinRustAsync_NestedCopyWithImpl(this._self, this._then);

  final KitchenSinkTwinRustAsync_Nested _self;
  final $Res Function(KitchenSinkTwinRustAsync_Nested) _then;

  /// Create a copy of KitchenSinkTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
  }) {
    return _then(KitchenSinkTwinRustAsync_Nested(
      null == field0
          ? _self.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
      null == field1
          ? _self.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as KitchenSinkTwinRustAsync,
    ));
  }

  /// Create a copy of KitchenSinkTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $KitchenSinkTwinRustAsyncCopyWith<$Res> get field1 {
    return $KitchenSinkTwinRustAsyncCopyWith<$Res>(_self.field1, (value) {
      return _then(_self.copyWith(field1: value));
    });
  }
}

/// @nodoc

class KitchenSinkTwinRustAsync_Optional extends KitchenSinkTwinRustAsync {
  const KitchenSinkTwinRustAsync_Optional([this.field0 = -1, this.field1])
      : super._();

  /// Comment on anonymous field
  @JsonKey()
  final int? field0;
  final int? field1;

  /// Create a copy of KitchenSinkTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $KitchenSinkTwinRustAsync_OptionalCopyWith<KitchenSinkTwinRustAsync_Optional>
      get copyWith => _$KitchenSinkTwinRustAsync_OptionalCopyWithImpl<
          KitchenSinkTwinRustAsync_Optional>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is KitchenSinkTwinRustAsync_Optional &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1);

  @override
  String toString() {
    return 'KitchenSinkTwinRustAsync.optional(field0: $field0, field1: $field1)';
  }
}

/// @nodoc
abstract mixin class $KitchenSinkTwinRustAsync_OptionalCopyWith<$Res>
    implements $KitchenSinkTwinRustAsyncCopyWith<$Res> {
  factory $KitchenSinkTwinRustAsync_OptionalCopyWith(
          KitchenSinkTwinRustAsync_Optional value,
          $Res Function(KitchenSinkTwinRustAsync_Optional) _then) =
      _$KitchenSinkTwinRustAsync_OptionalCopyWithImpl;
  @useResult
  $Res call({int? field0, int? field1});
}

/// @nodoc
class _$KitchenSinkTwinRustAsync_OptionalCopyWithImpl<$Res>
    implements $KitchenSinkTwinRustAsync_OptionalCopyWith<$Res> {
  _$KitchenSinkTwinRustAsync_OptionalCopyWithImpl(this._self, this._then);

  final KitchenSinkTwinRustAsync_Optional _self;
  final $Res Function(KitchenSinkTwinRustAsync_Optional) _then;

  /// Create a copy of KitchenSinkTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? field0 = freezed,
    Object? field1 = freezed,
  }) {
    return _then(KitchenSinkTwinRustAsync_Optional(
      freezed == field0
          ? _self.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int?,
      freezed == field1
          ? _self.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class KitchenSinkTwinRustAsync_Buffer extends KitchenSinkTwinRustAsync {
  const KitchenSinkTwinRustAsync_Buffer(this.field0) : super._();

  final Uint8List field0;

  /// Create a copy of KitchenSinkTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $KitchenSinkTwinRustAsync_BufferCopyWith<KitchenSinkTwinRustAsync_Buffer>
      get copyWith => _$KitchenSinkTwinRustAsync_BufferCopyWithImpl<
          KitchenSinkTwinRustAsync_Buffer>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is KitchenSinkTwinRustAsync_Buffer &&
            const DeepCollectionEquality().equals(other.field0, field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(field0));

  @override
  String toString() {
    return 'KitchenSinkTwinRustAsync.buffer(field0: $field0)';
  }
}

/// @nodoc
abstract mixin class $KitchenSinkTwinRustAsync_BufferCopyWith<$Res>
    implements $KitchenSinkTwinRustAsyncCopyWith<$Res> {
  factory $KitchenSinkTwinRustAsync_BufferCopyWith(
          KitchenSinkTwinRustAsync_Buffer value,
          $Res Function(KitchenSinkTwinRustAsync_Buffer) _then) =
      _$KitchenSinkTwinRustAsync_BufferCopyWithImpl;
  @useResult
  $Res call({Uint8List field0});
}

/// @nodoc
class _$KitchenSinkTwinRustAsync_BufferCopyWithImpl<$Res>
    implements $KitchenSinkTwinRustAsync_BufferCopyWith<$Res> {
  _$KitchenSinkTwinRustAsync_BufferCopyWithImpl(this._self, this._then);

  final KitchenSinkTwinRustAsync_Buffer _self;
  final $Res Function(KitchenSinkTwinRustAsync_Buffer) _then;

  /// Create a copy of KitchenSinkTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? field0 = null,
  }) {
    return _then(KitchenSinkTwinRustAsync_Buffer(
      null == field0
          ? _self.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc

class KitchenSinkTwinRustAsync_Enums extends KitchenSinkTwinRustAsync {
  const KitchenSinkTwinRustAsync_Enums(
      [this.field0 = WeekdaysTwinRustAsync.sunday])
      : super._();

  @JsonKey()
  final WeekdaysTwinRustAsync field0;

  /// Create a copy of KitchenSinkTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $KitchenSinkTwinRustAsync_EnumsCopyWith<KitchenSinkTwinRustAsync_Enums>
      get copyWith => _$KitchenSinkTwinRustAsync_EnumsCopyWithImpl<
          KitchenSinkTwinRustAsync_Enums>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is KitchenSinkTwinRustAsync_Enums &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @override
  String toString() {
    return 'KitchenSinkTwinRustAsync.enums(field0: $field0)';
  }
}

/// @nodoc
abstract mixin class $KitchenSinkTwinRustAsync_EnumsCopyWith<$Res>
    implements $KitchenSinkTwinRustAsyncCopyWith<$Res> {
  factory $KitchenSinkTwinRustAsync_EnumsCopyWith(
          KitchenSinkTwinRustAsync_Enums value,
          $Res Function(KitchenSinkTwinRustAsync_Enums) _then) =
      _$KitchenSinkTwinRustAsync_EnumsCopyWithImpl;
  @useResult
  $Res call({WeekdaysTwinRustAsync field0});
}

/// @nodoc
class _$KitchenSinkTwinRustAsync_EnumsCopyWithImpl<$Res>
    implements $KitchenSinkTwinRustAsync_EnumsCopyWith<$Res> {
  _$KitchenSinkTwinRustAsync_EnumsCopyWithImpl(this._self, this._then);

  final KitchenSinkTwinRustAsync_Enums _self;
  final $Res Function(KitchenSinkTwinRustAsync_Enums) _then;

  /// Create a copy of KitchenSinkTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? field0 = null,
  }) {
    return _then(KitchenSinkTwinRustAsync_Enums(
      null == field0
          ? _self.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as WeekdaysTwinRustAsync,
    ));
  }
}

/// @nodoc
mixin _$MeasureTwinRustAsync {
  Object get field0;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MeasureTwinRustAsync &&
            const DeepCollectionEquality().equals(other.field0, field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(field0));

  @override
  String toString() {
    return 'MeasureTwinRustAsync(field0: $field0)';
  }
}

/// @nodoc
class $MeasureTwinRustAsyncCopyWith<$Res> {
  $MeasureTwinRustAsyncCopyWith(
      MeasureTwinRustAsync _, $Res Function(MeasureTwinRustAsync) __);
}

/// @nodoc

class MeasureTwinRustAsync_Speed extends MeasureTwinRustAsync {
  const MeasureTwinRustAsync_Speed(this.field0) : super._();

  @override
  final SpeedTwinRustAsync field0;

  /// Create a copy of MeasureTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MeasureTwinRustAsync_SpeedCopyWith<MeasureTwinRustAsync_Speed>
      get copyWith =>
          _$MeasureTwinRustAsync_SpeedCopyWithImpl<MeasureTwinRustAsync_Speed>(
              this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MeasureTwinRustAsync_Speed &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @override
  String toString() {
    return 'MeasureTwinRustAsync.speed(field0: $field0)';
  }
}

/// @nodoc
abstract mixin class $MeasureTwinRustAsync_SpeedCopyWith<$Res>
    implements $MeasureTwinRustAsyncCopyWith<$Res> {
  factory $MeasureTwinRustAsync_SpeedCopyWith(MeasureTwinRustAsync_Speed value,
          $Res Function(MeasureTwinRustAsync_Speed) _then) =
      _$MeasureTwinRustAsync_SpeedCopyWithImpl;
  @useResult
  $Res call({SpeedTwinRustAsync field0});

  $SpeedTwinRustAsyncCopyWith<$Res> get field0;
}

/// @nodoc
class _$MeasureTwinRustAsync_SpeedCopyWithImpl<$Res>
    implements $MeasureTwinRustAsync_SpeedCopyWith<$Res> {
  _$MeasureTwinRustAsync_SpeedCopyWithImpl(this._self, this._then);

  final MeasureTwinRustAsync_Speed _self;
  final $Res Function(MeasureTwinRustAsync_Speed) _then;

  /// Create a copy of MeasureTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? field0 = null,
  }) {
    return _then(MeasureTwinRustAsync_Speed(
      null == field0
          ? _self.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as SpeedTwinRustAsync,
    ));
  }

  /// Create a copy of MeasureTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $SpeedTwinRustAsyncCopyWith<$Res> get field0 {
    return $SpeedTwinRustAsyncCopyWith<$Res>(_self.field0, (value) {
      return _then(_self.copyWith(field0: value));
    });
  }
}

/// @nodoc

class MeasureTwinRustAsync_Distance extends MeasureTwinRustAsync {
  const MeasureTwinRustAsync_Distance(this.field0) : super._();

  @override
  final DistanceTwinRustAsync field0;

  /// Create a copy of MeasureTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MeasureTwinRustAsync_DistanceCopyWith<MeasureTwinRustAsync_Distance>
      get copyWith => _$MeasureTwinRustAsync_DistanceCopyWithImpl<
          MeasureTwinRustAsync_Distance>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MeasureTwinRustAsync_Distance &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @override
  String toString() {
    return 'MeasureTwinRustAsync.distance(field0: $field0)';
  }
}

/// @nodoc
abstract mixin class $MeasureTwinRustAsync_DistanceCopyWith<$Res>
    implements $MeasureTwinRustAsyncCopyWith<$Res> {
  factory $MeasureTwinRustAsync_DistanceCopyWith(
          MeasureTwinRustAsync_Distance value,
          $Res Function(MeasureTwinRustAsync_Distance) _then) =
      _$MeasureTwinRustAsync_DistanceCopyWithImpl;
  @useResult
  $Res call({DistanceTwinRustAsync field0});

  $DistanceTwinRustAsyncCopyWith<$Res> get field0;
}

/// @nodoc
class _$MeasureTwinRustAsync_DistanceCopyWithImpl<$Res>
    implements $MeasureTwinRustAsync_DistanceCopyWith<$Res> {
  _$MeasureTwinRustAsync_DistanceCopyWithImpl(this._self, this._then);

  final MeasureTwinRustAsync_Distance _self;
  final $Res Function(MeasureTwinRustAsync_Distance) _then;

  /// Create a copy of MeasureTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? field0 = null,
  }) {
    return _then(MeasureTwinRustAsync_Distance(
      null == field0
          ? _self.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as DistanceTwinRustAsync,
    ));
  }

  /// Create a copy of MeasureTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $DistanceTwinRustAsyncCopyWith<$Res> get field0 {
    return $DistanceTwinRustAsyncCopyWith<$Res>(_self.field0, (value) {
      return _then(_self.copyWith(field0: value));
    });
  }
}

/// @nodoc
mixin _$SpeedTwinRustAsync {
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is SpeedTwinRustAsync);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'SpeedTwinRustAsync()';
  }
}

/// @nodoc
class $SpeedTwinRustAsyncCopyWith<$Res> {
  $SpeedTwinRustAsyncCopyWith(
      SpeedTwinRustAsync _, $Res Function(SpeedTwinRustAsync) __);
}

/// @nodoc

class SpeedTwinRustAsync_Unknown extends SpeedTwinRustAsync {
  const SpeedTwinRustAsync_Unknown() : super._();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SpeedTwinRustAsync_Unknown);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'SpeedTwinRustAsync.unknown()';
  }
}

/// @nodoc

class SpeedTwinRustAsync_GPS extends SpeedTwinRustAsync {
  const SpeedTwinRustAsync_GPS(this.field0) : super._();

  final double field0;

  /// Create a copy of SpeedTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $SpeedTwinRustAsync_GPSCopyWith<SpeedTwinRustAsync_GPS> get copyWith =>
      _$SpeedTwinRustAsync_GPSCopyWithImpl<SpeedTwinRustAsync_GPS>(
          this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SpeedTwinRustAsync_GPS &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @override
  String toString() {
    return 'SpeedTwinRustAsync.gps(field0: $field0)';
  }
}

/// @nodoc
abstract mixin class $SpeedTwinRustAsync_GPSCopyWith<$Res>
    implements $SpeedTwinRustAsyncCopyWith<$Res> {
  factory $SpeedTwinRustAsync_GPSCopyWith(SpeedTwinRustAsync_GPS value,
          $Res Function(SpeedTwinRustAsync_GPS) _then) =
      _$SpeedTwinRustAsync_GPSCopyWithImpl;
  @useResult
  $Res call({double field0});
}

/// @nodoc
class _$SpeedTwinRustAsync_GPSCopyWithImpl<$Res>
    implements $SpeedTwinRustAsync_GPSCopyWith<$Res> {
  _$SpeedTwinRustAsync_GPSCopyWithImpl(this._self, this._then);

  final SpeedTwinRustAsync_GPS _self;
  final $Res Function(SpeedTwinRustAsync_GPS) _then;

  /// Create a copy of SpeedTwinRustAsync
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? field0 = null,
  }) {
    return _then(SpeedTwinRustAsync_GPS(
      null == field0
          ? _self.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

// dart format on
